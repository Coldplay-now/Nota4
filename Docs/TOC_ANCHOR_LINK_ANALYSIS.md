# TOC 和锚点链接问题分析

## 问题描述

在预览模式下，TOC 链接和 Markdown 内链的点击行为不一致：
- 有些链接可以正常跳转到指定位置
- 有些链接点击无效

## 代码流程分析

### 1. 渲染流程

```
Markdown 文本
  ↓
preprocess() - 提取 Mermaid、数学公式、代码块
  ↓
Ink parser.html() - Markdown → HTML
  ↓
addHeadingIds() - 为标题添加 id 属性
  ↓
highlightCodeBlocks() - 代码高亮
  ↓
injectMermaidCharts() - 注入 Mermaid
  ↓
injectMathFormulas() - 注入数学公式
  ↓
generateTOC() - 生成 TOC（从原始 Markdown）
  ↓
buildFullHTML() - 构建完整 HTML
```

### 2. TOC 生成逻辑 (`generateTOC`)

**位置**: `MarkdownRenderer.swift:306-344`

**输入**: 原始 Markdown 文本

**处理**:
1. 逐行扫描，查找以 `#` 开头的标题行
2. 提取标题文本：`line.dropFirst(level).trimmingCharacters(in: .whitespaces)`
3. 生成 ID：
   ```swift
   let id = title.lowercased()
       .replacingOccurrences(of: " ", with: "-")
       .replacingOccurrences(of: "[^a-z0-9\\-]", with: "", options: .regularExpression)
   ```
4. 生成 TOC 链接：`<a href="#\(id)">\(escapeHTML(title))</a>`

**特点**:
- 使用原始 Markdown 文本
- 标题文本是纯文本（未经过 HTML 转义）
- ID 生成基于纯文本

### 3. 标题 ID 添加逻辑 (`addHeadingIds`)

**位置**: `MarkdownRenderer.swift:144-196`

**输入**: Ink 解析后的 HTML

**处理**:
1. 使用正则表达式匹配标题：`<(h[1-6])([^>]*)>([^<]+)</h[1-6]>`
2. 提取标题文本：`([^<]+)` - **这里有问题！**
3. 生成 ID（与 TOC 相同的逻辑）
4. 添加 id 属性到标题标签

**问题点**:

#### 问题 1: 正则表达式无法处理包含 HTML 标签的标题

**示例**:
- Markdown: `# 这是**加粗**标题`
- Ink 输出: `<h1>这是<strong>加粗</strong>标题</h1>`
- 正则匹配: `([^<]+)` 只能匹配到 `这是`，遇到 `<` 就停止
- 结果: ID 生成错误，只基于 `这是`，而不是完整标题

#### 问题 2: HTML 实体未解码

**示例**:
- Markdown: `# 标题 & 副标题`
- Ink 输出: `<h1>标题 &amp; 副标题</h1>`
- `addHeadingIds` 提取: `标题 &amp; 副标题`
- ID 生成: `标题-amp-副标题` ❌
- TOC 生成（从原始 Markdown）: `标题-副标题` ✅
- **结果**: ID 不一致！

#### 问题 3: 标题文本提取不完整

**当前正则**: `([^<]+)` 在遇到任何 `<` 字符时停止，包括：
- HTML 标签：`<strong>`, `<em>`, `<code>` 等
- HTML 实体：`&lt;`, `&gt;` 等（虽然这些在 HTML 中已经是 `<` 和 `>`）

**影响**:
- 如果标题包含格式化（加粗、斜体等），ID 生成不完整
- 如果标题包含 HTML 实体，ID 生成错误

### 4. Markdown 内链处理

**Ink 处理**:
- `[链接文本](#标题-id)` → `<a href="#标题-id">链接文本</a>`
- 用户手动写的 ID 可能与自动生成的 ID 不一致

**问题**:
- 用户不知道自动生成的 ID 规则
- 如果用户写的 ID 和自动生成的 ID 不一致，链接失效

### 5. 链接点击处理 (`WebViewWrapper`)

**位置**: `WebViewWrapper.swift:32-90`

**处理**:
1. 检测是否为内部锚点链接
2. 提取 fragment（锚点 ID）
3. 使用 JavaScript 查找元素：`document.getElementById('\(fragment)')`
4. 滚动到元素位置

**潜在问题**:
- 如果元素不存在（ID 不匹配），`getElementById` 返回 `null`，不会滚动
- 没有错误提示，用户不知道链接为什么无效

## 问题总结

### 核心问题

1. **ID 生成不一致**:
   - TOC 从原始 Markdown 生成 ID（纯文本）
   - 标题 ID 从 HTML 生成（可能包含 HTML 实体、HTML 标签）
   - 两者可能生成不同的 ID

2. **正则表达式限制**:
   - `addHeadingIds` 使用的正则 `([^<]+)` 无法处理包含 HTML 标签的标题
   - 只能提取标题的第一部分文本

3. **HTML 实体未处理**:
   - HTML 中的 `&amp;` 等实体未解码
   - 导致 ID 生成包含 `amp` 等字符

4. **用户手动链接 ID 不匹配**:
   - 用户不知道自动生成的 ID 规则
   - 手动写的 ID 可能不匹配

### 影响范围

- ✅ **简单标题**（纯文本，无特殊字符）: 正常工作
- ❌ **包含格式化的标题**（加粗、斜体等）: ID 生成不完整
- ❌ **包含特殊字符的标题**（`&`, `<`, `>` 等）: ID 生成错误
- ❌ **用户手动写的内链**: 可能 ID 不匹配

## 建议修复方案

### 方案 1: 统一 ID 生成源（推荐）

**思路**: 都从原始 Markdown 生成 ID，然后映射到 HTML

1. 在 `generateTOC` 时，记录标题文本和生成的 ID 的映射
2. 在 `addHeadingIds` 时，使用相同的映射来添加 ID
3. 确保 ID 生成逻辑完全一致

### 方案 2: 改进 HTML 标题文本提取

**思路**: 正确提取 HTML 标题中的纯文本

1. 使用更强大的正则或 HTML 解析器提取标题文本
2. 解码 HTML 实体（`&amp;` → `&`）
3. 移除 HTML 标签，只保留纯文本
4. 使用与 TOC 相同的 ID 生成逻辑

### 方案 3: 使用 HTML 解析器

**思路**: 使用专业的 HTML 解析器（如 SwiftSoup）来提取标题

1. 解析 HTML DOM
2. 查找所有 h1-h6 元素
3. 提取纯文本内容（自动处理 HTML 标签和实体）
4. 生成 ID 并添加属性

## 测试用例

### 测试用例 1: 简单标题
```markdown
# 简单标题
```
- TOC ID: `简单标题`
- 标题 ID: `简单标题`
- **预期**: ✅ 一致

### 测试用例 2: 包含格式化的标题
```markdown
# 这是**加粗**标题
```
- TOC ID: `这是加粗标题`（从原始 Markdown）
- 标题 ID: `这是`（从 HTML，正则只匹配到 `<` 前）
- **预期**: ❌ 不一致

### 测试用例 3: 包含特殊字符
```markdown
# 标题 & 副标题
```
- TOC ID: `标题-副标题`（从原始 Markdown，`&` 被移除）
- 标题 ID: `标题-amp-副标题`（从 HTML，`&amp;` 未解码）
- **预期**: ❌ 不一致

### 测试用例 4: 包含 HTML 实体
```markdown
# 标题 < 副标题
```
- TOC ID: `标题-副标题`（从原始 Markdown）
- 标题 ID: `标题-副标题`（从 HTML，`&lt;` 已解码为 `<`，但正则在 `<` 处停止）
- **预期**: ❌ 可能不一致

## 结论

**主要问题**: `addHeadingIds` 方法无法正确处理包含 HTML 标签或 HTML 实体的标题，导致生成的 ID 与 TOC 中的 ID 不一致。

**建议**: 采用方案 1 或方案 2，确保 ID 生成的一致性。

---

## 框架价值：超越 TOC/内链的优化

这些优化方案不仅解决了 TOC 和锚点链接的问题，还为整个 Markdown 渲染系统建立了更统一、更可靠的框架基础：

### 1. **统一的 HTML 文本提取框架**

**当前问题**: 从 HTML 中提取纯文本的能力不足，导致：
- 标题 ID 生成错误
- 其他需要从 HTML 提取文本的功能也可能受影响

**优化价值**:
- ✅ 建立可复用的 HTML 文本提取工具函数
- ✅ 正确处理 HTML 实体解码（`&amp;` → `&`）
- ✅ 正确处理 HTML 标签移除（`<strong>文本</strong>` → `文本`）
- ✅ 可应用于：搜索索引、文本摘要、导出纯文本等功能

### 2. **统一的 ID 生成机制**

**当前问题**: ID 生成逻辑分散，容易不一致

**优化价值**:
- ✅ 建立统一的 ID 生成函数 `generateID(from:)`
- ✅ 确保所有地方（TOC、标题、内链）使用相同的规则
- ✅ 可应用于：标签 ID、分类 ID、其他需要唯一标识符的场景

### 3. **改进的 HTML 后处理流程**

**当前流程**:
```
Markdown → Ink → HTML → 各种后处理（代码高亮、Mermaid、数学公式、标题 ID）
```

**优化后的流程**:
```
Markdown → Ink → HTML → 标准化处理（HTML 清理、文本提取）→ 各种后处理
```

**优化价值**:
- ✅ 建立 HTML 标准化处理层，确保后续处理都基于干净的 HTML
- ✅ 减少重复的 HTML 解析和处理逻辑
- ✅ 提高代码可维护性和可扩展性

### 4. **更可靠的渲染后处理能力**

**当前限制**: 正则表达式处理 HTML 的能力有限

**优化价值**:
- ✅ 如果采用方案 3（HTML 解析器），可以：
  - 更准确地提取 HTML 元素
  - 处理复杂的 HTML 结构
  - 支持未来的 HTML 增强功能（如自定义 HTML 块、HTML 表格等）

### 5. **为未来功能奠定基础**

这些优化为以下未来功能提供了基础：

**搜索和索引**:
- 需要从 HTML 提取纯文本进行搜索
- 统一的文本提取框架可以直接使用

**导出功能**:
- 导出为纯文本、PDF 等格式
- 需要从 HTML 提取纯文本
- 统一的文本提取框架可以直接使用

**内容分析**:
- 字数统计、阅读时间估算等
- 需要准确的文本提取
- 统一的文本提取框架可以直接使用

**链接处理增强**:
- 自动修复断链
- 链接预览
- 需要准确的 ID 生成和匹配

**目录生成增强**:
- 多级目录
- 目录折叠
- 需要可靠的标题 ID 生成

### 6. **代码质量提升**

**当前问题**: 
- HTML 处理逻辑分散
- 重复的文本提取代码
- 不一致的处理逻辑

**优化价值**:
- ✅ 代码复用性提高
- ✅ 维护成本降低
- ✅ 测试更容易（统一的工具函数）
- ✅ 扩展性更好（新功能可以复用现有框架）

## 总结

这些优化方案的价值不仅在于解决当前的 TOC/内链问题，更重要的是：

1. **建立基础设施**: 统一的 HTML 文本提取、ID 生成等基础工具
2. **提高可靠性**: 确保所有功能都基于一致、可靠的处理逻辑
3. **支持扩展**: 为未来的功能需求提供坚实的基础
4. **提升质量**: 提高代码的可维护性、可测试性和可扩展性

这是一个**从修复 bug 到建立框架**的升级，为整个渲染系统的长期发展奠定了坚实的基础。

